#include <iostream>
using namespace std;

void main()
	// memset ( 바꿀 주소, 초기화될 값, 주소의 크기);
{	// - 메모리 초기화, 동적 데이터에 유용함.
	// - 1바이트씩 연산
	// eX)
	//int a;
	//memset(&a, 1, sizeof(a));	// 0을 제외한 숫자로 초기화시
	//cout << a << endl;			// int는 4바이트라 1바이트마다 1으로 초기화되서 값이 저렇게 나옴


	// memcpy(바꿀 주소, 복사할 주소, 복사할 크기)
	// - 메모리를 바로 복사함.
	// - dest와 src가 겹치면 겹친부분이 또 복사되서 데이터가 변조될 수 있음.
	// - src의 크기보다 큰 크기를 복사하려하면 src뒤의 쓰레기값을 가져감.
	//int src[5] = { 1,2,3,4,5 };
	//int dest[10] = {};
	//memcpy(dest, src, sizeof(dest));	
	//for (int i = 0; i < 10; ++i)
	//	cout << dest[i] << " ";


	// memmove(바꿀 주소, 복사할 주소, 복사할 크기)   // dest와 src가 겹칠때 사용.
	// - 메모리를 임시 버퍼로 옴긴후 복사. (복사가 2번 일어남. memcpy보다 느림)
	// - dest와 src의 메모리가 겹쳐도 에러가 문제가없다.
	//   즉, 임시 버퍼로 이동해서 옴기기 때문에 안정성(데이터변질안됨)이 더좋음





	// ########################## 동적 할당 ############################
	// 함수를 벗어나 의미없어진 주소 = dangling pointer 

	// c언어의 동적할당
	// - (pointer casting)malloc(자료형 크기)
	//	 기본 동적할당
	//
	// - (pointer casting)calloc(갯수, 자료형 크기)
	//	 배열 동적할당 (calloc은 자동으로 0초기화)
	//
	// - (pointer casting)realloc(자료형 크기)
	//   할당된 주소를 다시 할당


	// c언어의 동적해제
	// - free(동적할당 변수)
	//   동적할당된 것들을 메모리 해제함. (동적할당을 한 후 꼭해야됨)
	// *** dangling pointer를 방지하기 위해 사용후 nullptr 초기화 할것
	// *** sizeof로 동적배열을 크기를 알려해도 포인터라 4바이트만나엄
	// *** 명시적으로 형변환을 해야하고 c언어 동적할당은 클래스의 생성자를 호출하지 않는다.

	
	// #####################################################################
	// c++ 동적할당
	// - new로 할당, delete 연산자로 해제
	// ex) 
	// int a = new int;
	// delete(a);

	// - 동적 배열
	// int* ptr = new int[배열크기];
	// int* ptr = new int[배열크기]{};		// 모든 원소 0으로 초기화.
	// delete[] ptr;						// 배열은 delete뒤에 []를 붙여야됨


}